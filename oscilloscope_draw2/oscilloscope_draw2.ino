// Рисование текста и простейшей графики на экране осциллографа.
// Для С1-94 развертка установлена 0.1 ms Время/дел.
// Включена внешняя синхронизация, ждущий режим
// Входной делитель 0.2 V/дел.

// Функции для рисования графики с разрешением 8х35 на экране осциллографа:
// void beginDraw() - Начало блока рисования. Все следующие beginDraw() за функции рисования не вызывают изменений на экране, 
// но их результат будет применен сразу после завершения блока endDraw()
// void endDraw() - завершение блока рисования
// void clearScreen() - очистка экрана
// void putPixel(char x, char y, bool cl) - рисует точку с координатами (x, y). 
// Если параметр cl = true, точка рисуется подсвеченным пикселем и черным в противном случае.
// void printText(char* text, int ofs = 0) - выводит на экран текст text с отступом от левого края ofs пикселей. 
// Непоместившаяся часть изображения отрезается
// void drawRect(int x1, int y1, int x2, int y2, bool cl) - рисует прямоугольник с левым верхним углом (x1, y1) и правым нижним (x2, y2). 
// Если параметр с1 == true, то прямоугольник рисуется светлыми пикселями и черными в противном случае.
// void fillRect(int x1, int y1, int x2, int y2, bool cl) - рисует закрашенный прямоугольник с левым верхним углом (x1, y1) и правым нижним (x2, y2). 
// Если параметр с1 == true, то прямоугольник рисуется светлыми пикселями и черными в противном случае.

const int C_SCREEN_WIDTH = 35;
const int C_SCREEN_HEIGHT = 8;
const int C_RAY_WAY_LENGTH = 60; // Номер "пикселя", после которого происходит переход на новую строку
                       // Для достижения устойчивой синхронизации может потребоваться варьировать значение этой константы,
                       // но оно не должно быть меньше 35, иначе не успеют нарисоваться все символы раньше,
                       // чем перейдем на новую строку

char screenData[C_SCREEN_WIDTH];
char drawData[C_SCREEN_WIDTH];
bool isDrawing = false;
char *drawTarget = screenData;

unsigned char charData[128][5] = 
{
{0x0, 0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0},
{0x0, 0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0},
{0x0, 0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0},
{0x0, 0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0},
{0x0, 0x0, 0x0, 0x0, 0x0}, {0x0, 0xfd, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0},
{0x0, 0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0}, {0xd, 0xe, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0}, {0x0, 0x3, 0x3, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0},
{0x7e, 0x81, 0x81, 0x7e, 0x0}, {0x10, 0x20, 0x40, 0xff, 0x0}, {0x43, 0x85, 0x89, 0x71, 0x0}, {0x42, 0x81, 0x99, 0x66, 0x0}, {0xf0, 0x10, 0x10, 0xff, 0x0}, {0x62, 0x91, 0x91, 0x8e, 0x0}, {0x6e, 0x91, 0x91, 0x4e, 0x0}, {0x83, 0x84, 0x88, 0x70, 0x0},
{0x6e, 0x91, 0x91, 0x6e, 0x0}, {0x72, 0x89, 0x89, 0x76, 0x0}, {0x0, 0x0, 0xc3, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0}, {0x40, 0x8d, 0x88, 0x70, 0x0},
{0x0, 0x0, 0x0, 0x0, 0x0}, {0x7f, 0x88, 0x88, 0x7f, 0x0}, {0xff, 0x91, 0x91, 0x6e, 0x0}, {0x7e, 0x81, 0x81, 0x42, 0x0}, {0xff, 0x81, 0x42, 0x3c, 0x0}, {0xff, 0x89, 0x89, 0x89, 0x0}, {0xff, 0x90, 0x90, 0x80, 0x0}, {0x7e, 0x81, 0x89, 0x4e, 0x0},
{0xff, 0x8, 0x8, 0xff, 0x0}, {0x0, 0x81, 0xff, 0x81, 0x0}, {0x6, 0x1, 0x81, 0x7e, 0x0}, {0xff, 0x18, 0x66, 0x81, 0x0}, {0xff, 0x1, 0x1, 0x1, 0x0}, {0xff, 0x60, 0x18, 0x60, 0xff}, {0xff, 0x38, 0xe, 0xff, 0x0}, {0x7e, 0x81, 0x81, 0x7e, 0x0},
{0x7f, 0x88, 0x88, 0x70, 0x0}, {0x7e, 0x81, 0x85, 0x7e, 0x1}, {0x7f, 0x8c, 0x8a, 0x71, 0x0}, {0x62, 0x91, 0x91, 0x4e, 0x0}, {0x0, 0x80, 0xff, 0x80, 0x0}, {0xfe, 0x1, 0x1, 0xfe, 0x0}, {0xe0, 0x1c, 0x3, 0x1c, 0xe0}, {0xff, 0xc, 0x30, 0xc, 0xff},
{0xc3, 0x3c, 0x3c, 0xc3, 0x0}, {0xc0, 0x30, 0xf, 0x30, 0xc0}, {0xc1, 0xb1, 0x8d, 0x83, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0},
{0x0, 0x0, 0x0, 0x0, 0x0}, {0x6, 0x29, 0x29, 0x16, 0x0}, {0xf6, 0x9, 0x9, 0x6, 0x0}, {0x1e, 0x21, 0x21, 0x12, 0x0}, {0x6, 0x9, 0x9, 0xf6, 0x0}, {0x1e, 0x25, 0x25, 0x19, 0x0}, {0x10, 0xff, 0x90, 0x0, 0x0}, {0x19, 0x25, 0x25, 0x1e, 0x0},
{0xff, 0x10, 0x10, 0xf, 0x0}, {0x0, 0x5f, 0x0, 0x0, 0x0}, {0x2, 0x1, 0x1, 0x5e, 0x0}, {0xff, 0x4, 0xa, 0x11, 0x0}, {0x0, 0x40, 0xff, 0x0, 0x0}, {0x3f, 0x20, 0x1f, 0x20, 0x1f}, {0x3f, 0x20, 0x20, 0x1f, 0x0}, {0x1e, 0x21, 0x21, 0x1e, 0x0},
{0x1f, 0x24, 0x24, 0x18, 0x0}, {0x18, 0x24, 0x24, 0x1f, 0x0}, {0x1f, 0x20, 0x20, 0x10, 0x0}, {0x11, 0x29, 0x29, 0x26, 0x0}, {0x20, 0xff, 0x21, 0x0, 0x0}, {0x3e, 0x1, 0x1, 0x3e, 0x0}, {0x38, 0x6, 0x1, 0x6, 0x38}, {0x3f, 0x2, 0x4, 0x2, 0x3f},
{0x21, 0x1e, 0x1e, 0x21, 0x0}, {0x39, 0x5, 0x5, 0x3a, 0x0}, {0x31, 0x29, 0x25, 0x23, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0, 0x0}
};

void clearScreen()
{
  memset(drawTarget, 0, C_SCREEN_WIDTH);
}

void putPixel(char x, char y, bool setOn)
{
  if (x >= 0 && x < C_SCREEN_WIDTH && y >= 0 && y < C_SCREEN_HEIGHT)
  {
    y = C_SCREEN_HEIGHT - y - 1;
    if (setOn)
      drawTarget[x] |= 1 << y;
    else
      drawTarget[x] &= !(1 << y);
  }
}

void beginDraw()
{
  isDrawing = true;
  drawTarget = drawData;
}

void endDraw()
{
  isDrawing = false;
  memcpy(screenData, drawData, C_SCREEN_WIDTH);
  drawTarget = screenData;
}

void drawV(int x, int y1, int y2, bool cl)
{
  if (x >= 0 && x < C_SCREEN_WIDTH)
  {
    y1 = max(y1, 0);
    y2 = min(C_SCREEN_HEIGHT, y2);
    for (int y = y1; y <= y2; y++)
      if (cl)
        drawTarget[x] |= (0x80 >> y);
      else
        drawTarget[x] &= ~(0x80 >> y);
  }
}

void drawH(int y, int x1, int x2, bool cl)
{
  if (y >= 0 && y < C_SCREEN_HEIGHT)
  {
    x1 = max(x1, 0);
    x2 = min(x2, C_SCREEN_WIDTH);
    for (int x = x1; x <= x2; x++)
      if (cl)
        drawTarget[x] |= 0x80 >> y;
      else
        drawTarget[x] &= ~(0x80 >> y);
  }
}

void drawRect(int x1, int y1, int x2, int y2, bool cl)
{
  drawV(x1, y1, y2, cl);
  drawV(x2, y1, y2, cl);
  drawH(y1, x1, x2, cl);
  drawH(y2, x1, x2, cl);
}

void fillRect(int x1, int y1, int x2, int y2, bool cl)
{
  y1 = max(y1, 0);
  y2 = min(C_SCREEN_HEIGHT - 1, y2);
  if (y1 >= C_SCREEN_HEIGHT || y2 < 0)
    return;
  x1 = max(x1, 0);
  x2 = min(x2, C_SCREEN_WIDTH - 1);
  if (x1 >= C_SCREEN_WIDTH|| x2 < 0)
    return;  
  char c = 0;
  for (int y = y1; y <= y2; y++)
    c |= 0x80 >> y;
  for (int x = x1; x <= x2; x++)
    if (cl)
      drawTarget[x] |= c;
    else
      drawTarget[x] &= ~c;
}

void printText(const char* text, int ofs = 0)
{
  clearScreen();
  int sl = strlen(text);
  int j = 0, q = 0;
  if (ofs < 0)
  {
    j = (-ofs)/5;
    q = (-ofs)%5;
  }
  for (int i = (ofs >=0) ? ofs: 0; i < C_SCREEN_WIDTH; i++)    
  {
    if (j < sl)
    {
      drawTarget[i] = charData[text[j]][q];
      q++;
      if (q == 5)
      {
        q = 0;
        j++;
      }
    }
    else
      break;
  }
}

void setup() {
// Пины 0, 1, 2, 3, 4 - на выход
  DDRD = DDRD | B00011111;
// Устанавливаем параметры таймера
  TCCR1A = 0;
  TCCR1B = 0;
  TCNT1  = 0;
// Таймер срабатывает 16 000 000 / 500 = 32 000 раз в секунду
  OCR1A = 500 - 1;
// Режим CTC
  TCCR1B |= (1 << WGM12);
// Предделитель выключен
  TCCR1B |= (0 << CS12) | (0 << CS11) | (1 << CS10); 
// Разрешаем прерывания таймера
  TIMSK1 |= (1 << OCIE1A);  
  clearScreen();  
}

int lev = 0; // Номер текущей строки растра
int col = 0; // Номер текущего "пикселя" в строке

ISR(TIMER1_COMPA_vect) {
  col = (col < C_RAY_WAY_LENGTH)?col + 1:0;
  if (col == C_RAY_WAY_LENGTH)     // Дошли до последнего "пикселя в строке" - даем синхроимпульс и переходим на следующую строку
  {
    PORTD = (PORTD & B11100000) | B00011000;
    PORTD = (PORTD & B11100000) | B00001000;
    lev = (lev < C_SCREEN_HEIGHT - 1)?lev + 1:0;
    return;
  }

  if (col < C_SCREEN_WIDTH && (screenData[col] >> lev) & 1)
    PORTD = (PORTD & B11100000) | lev;
  else
    PORTD = (PORTD & B11100000) | B00001000;
}

void loop() {
  // Бегущая строка
  for (int i = 35; i > -19*5; i--)
  {
    beginDraw();
    printText("Hello GeekTimes!!!", i);
    endDraw();
    delay(100);
  }
  clearScreen();
  // Проступающий текст
  for (int i = C_SCREEN_HEIGHT - 1; i >= -1; i--)
  {
    beginDraw();
    clearScreen();
    printText(" Green");
    fillRect(0, 0, C_SCREEN_WIDTH - 1, i, false);
    endDraw();
    delay(100);
  } 
  delay(1000);
  for (int i = C_SCREEN_HEIGHT - 1; i >= 0; i--)
  {
    beginDraw();
    clearScreen();
    printText(" Green");
    fillRect(0, i, C_SCREEN_WIDTH - 1, C_SCREEN_HEIGHT - 1, false);
    endDraw();
    delay(100);
  }   
  delay(1000);  
  // Прямоугольники на темном фоне  
  for (int j = 0; j < 3; j++)
    for (int i = 0; i < 5; i++)
    {
      beginDraw();
      clearScreen();
      for (int k = 0; k < 5; k++)
        drawRect(i + 7*k, i + 1, 7*k + 5 - i, 5 - i + 1, true);
      endDraw();  
      delay(100);
    }
  // Прямоугольники на светлом фоне
  for (int j = 0; j < 3; j++)
    for (int i = 0; i < 5; i++)
    {
      beginDraw();
      fillRect(0, 0, C_SCREEN_WIDTH, C_SCREEN_HEIGHT, true);
      for (int k = 0; k < 5; k++)
        drawRect(i + 7*k, i + 1, 7*k + 5 - i, 5 - i + 1, false);
      endDraw();  
      delay(100);
    }
  int dx1 = 1, dy1 = 1, dx2 = 1, dy2 = -1, x1 = 5, y1 = 2, x2 = 21, y2 = 3;
  for (int q = 0; q < 100; q++)
  {
    beginDraw();
    clearScreen();
    drawRect(0, 0, C_SCREEN_WIDTH - 1, C_SCREEN_HEIGHT - 1, true);    
    putPixel(x1, y1, true);
    putPixel(x1, y1 + 1, true);
    putPixel(x2, y2, true);
    putPixel(x2, y2 + 1, true);
    endDraw();
    if (x1 == C_SCREEN_WIDTH - 2 || x1 == 1)
      dx1 = -dx1;
    if (x2 == C_SCREEN_WIDTH - 2 || x2 == 1)
      dx2 = -dx2;
    if (y1 == C_SCREEN_HEIGHT - 3 || y1 == 1)
      dy1 = -dy1;
    if (y2 == C_SCREEN_HEIGHT - 3 || y2 == 1)
      dy2 = -dy2;
    x1 += dx1;
    y1 += dy1;
    x2 += dx2;
    y2 += dy2;
    delay(100);
  }  
}
